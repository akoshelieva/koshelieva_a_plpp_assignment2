# koshelieva_a_plpp_assignment2
Детальний тест-план, пояснення програми та використання парадигм програмування
1. Пояснення програми
Програма є реалізацією текстового редактора на C++, який надає базові функції для роботи з текстом, такі як додавання, вставка, видалення, копіювання, вирізання, вставлення тексту, а також збереження та завантаження тексту з файлу. Вона підтримує механізми скасування (undo) та повторення (redo) дій, а також пошук підрядків у тексті. Програма побудована з використанням об'єктно-орієнтованої парадигми програмування та має консольний інтерфейс для взаємодії з користувачем.
Основні компоненти програми:

Клас TextEditor: Містить логіку для маніпуляцій з текстом, управління буфером обміну та історією змін.
Інтерфейс користувача: Реалізовано в функції main(), яка надає меню для вибору команд.
Механізм історії змін: Використовує вектор для зберігання до 5 останніх станів тексту, що дозволяє скасовувати та повторювати дії.

2. Використання парадигм програмування
Програма використовує об'єктно-орієнтовану парадигму (ООП) як основну. Ось як застосовуються принципи ООП:

Інкапсуляція:

Дані (text, changes, clipboard, changes_index) є приватними (private) і доступні лише через методи класу TextEditor.
Наприклад, методи save_State() та get_position() є приватними, оскільки вони призначені лише для внутрішнього використання.


Абстракція:

Клас TextEditor надає простий інтерфейс для роботи з текстом (наприклад, append_text, insert_text, undo), приховуючи складність реалізації, таку як обчислення позиції в тексті чи управління історією змін.


Наслідування та поліморфізм:

У даній реалізації не використовуються, оскільки програма є відносно простою і не потребує ієрархії класів. Однак у майбутньому можна було б розширити програму, додавши класи-нащадки для різних типів редакторів (наприклад, HTML-редактор).


Модульність:

Код розділено на файли: заголовковий файл (text_editor.h), файл реалізації (text_editor.cpp) та основний файл (main.cpp). Це сприяє підтримці та розширенню коду.



Крім того, програма використовує елементи процедурного програмування в функції main(), де реалізовано цикл меню та обробку введення користувача. Це дозволяє чітко організувати взаємодію з користувачем, не ускладнюючи клас TextEditor.
3. Тест-план
Тест-план охоплює всі методи класу TextEditor та основні сценарії використання програми. Він включає модульні тести для перевірки окремих функцій, інтеграційні тести для перевірки взаємодії компонентів та тести для перевірки поведінки в крайових випадках.
3.1. Мета тестування
Переконатися, що всі методи класу TextEditor працюють коректно, обробляють помилки належним чином і відповідають вимогам функціональності. Перевірити взаємодію методів через консольний інтерфейс.
3.2. Обсяг тестування

Модульні тести: Перевірка кожного методу класу TextEditor.
Інтеграційні тести: Перевірка взаємодії методів (наприклад, збереження стану перед зміною тексту, скасування та повторення дій).
Тести крайових випадків: Перевірка поведінки програми при некоректних вхідних даних, порожньому тексті, максимальній кількості змін тощо.
Тести інтерфейсу: Перевірка коректності роботи меню в main().

3.3. Тестові сценарії
Модульні тести

Конструктор TextEditor::TextEditor():

Тест 1: Перевірити, що об'єкт ініціалізується з порожнім текстом, порожнім буфером обміну та changes_index = 0.
Очікуваний результат: text = "", clipboard = "", changes містить один елемент (порожній рядок), changes_index = 0.


Метод get_position(int line, int index):

Тест 1: Перевірити коректність обчислення позиції для тексту "Hello\nWorld" при line = 1, index = 2.
Очікуваний результат: Повертає позицію 7 (початок "r" у "World").


Тест 2: Перевірити викидання виключення при від'ємних line або index.
Очікуваний результат: std::out_of_range з повідомленням "Line and index must be non-negative."


Тест 3: Перевірити викидання виключення, якщо line або index виходять за межі тексту.
Очікуваний результат: std::out_of_range з відповідним повідомленням.




Метод save_State():

Тест 1: Перевірити, що новий стан додається до changes, а старі стани видаляються, якщо їх кількість перевищує MAX_changes (5).
Очікуваний результат: changes.size() <= 5, changes_index вказує на останній стан.


Тест 2: Перевірити, що при виклику після undo видаляються всі стани після changes_index.
Очікуваний результат: changes містить лише стани до поточного включно.




Метод append_text(const std::string& text_to_append):

Тест 1: Додати текст "Hello" до порожнього редактора.
Очікуваний результат: text = "Hello", стан збережено в changes.


Тест 2: Додати порожній рядок.
Очікуваний результат: text не змінюється, новий стан додається до changes.




Метод start_new_line():

Тест 1: Додати новий рядок до тексту "Hello".
Очікуваний результат: text = "Hello\n", стан збережено.


Тест 2: Додати новий рядок до порожнього тексту.
Очікуваний результат: text = "\n", стан збережено.




Метод insert_text(int line, int index, const std::string& text_to_insert):

Тест 1: Вставити "World" у текст "Hello\n" на позицію line = 0, index = 5.
Очікуваний результат: text = "HelloWorld\n", стан збережено.


Тест 2: Перевірити викидання виключення при некоректних line або index.
Очікуваний результат: std::out_of_range.




Метод delete_text(int line, int index, int number_of_symbols):

Тест 1: Видалити 2 символи з тексту "Hello" на позиції line = 0, index = 1.
Очікуваний результат: text = "Hlo", стан збережено.


Тест 2: Перевірити викидання виключення при від'ємному number_of_symbols.
Очікуваний результат: std::invalid_argument.




Метод replaceText(int line, int index, int number_of_symbols_to_replace, const std::string& text_to_insert):

Тест 1: Замінити 2 символи в тексті "Hello" на "XX" (line = 0, index = 1).
Очікуваний результат: text = "HXXlo", стан збережено.


Тест 2: Перевірити викидання виключення при від'ємному number_of_symbols_to_replace.
Очікуваний результат: std::invalid_argument.




Метод copyText(int line, int index, int number_of_symbols):

Тест 1: Скопіювати 3 символи з тексту "Hello" (line = 0, index = 0).
Очікуваний результат: clipboard = "Hel".


Тест 2: Скопіювати 0 символів.
Очікуваний результат: clipboard = "".




Метод cutText(int line, int index, int number_of_symbols):

Тест 1: Вирізати 2 символи з тексту "Hello" (line = 0, index = 1).
Очікуваний результат: text = "Hlo", clipboard = "el", стан збережено.


Тест 2: Вирізати 0 символів.
Очікуваний результат: clipboard = "", текст не змінюється.




Метод paste_text(int line, int index):

Тест 1: Вставити вмі



